---
layout: post
author: Jamie Sullivan
date:  2021-05-05 08:00:34 +1200
---
# Part (3a) DCNM and VXLAN BGP and EVPN Lab with Nexus 9000v
In this update we outline of the virtual lab topology used as the sandbox to explore APIs and Visualisations with Grafana and DCNM.  If you already have a DCNM environment available, you can skip this page and continue to Part 3.2.


| Section | Architecture | Link | Topic
------------ | ------------ | ------------- | -------------
1 | Introduction | [building a multidomain dashboard with cisco apis and grafana](https://j-sulliman.github.io/2021/04/26/Part-1-Intro-Building-a-Multidomain-Dashboard-with-Cisco-APIs-and-Grafana.html) | Solution Overview
2 | Meraki | [Building a Meraki Dashboard with Grafana, Django and Python](https://j-sulliman.github.io/2021/04/26/Part-2-Meraki-Building-a-Multidomain-Dashboard-with-Cisco-APIs-and-Grafana.html) | Visualising Meraki APIs with Grafana.
3.1 | DCNM & EVPN VXLAN | [DCNM and VXLAN BGP and EVPN Lab with Nexus 9000v](https://j-sulliman.github.io/2021/04/26/Part-3a-DCNM-Lab-Build-Building-a-Multidomain-Dashboard-with-Cisco-APIs-and-Grafana.html) | DCNM, N9000v, EVPN and VXLAN Lab deployment
3.2 | DCNM & EVPN VXLAN | Work In Progress | Visualising DCNM APIs with Grafana.


#### DCNM VXLAN BGP and EVPN Resources
* [DCNM REST API Reference Guide](https://developer.cisco.com/docs/data-center-network-manager/11-5-1/)
* [Easy Provisioning of VXLAN BGP EVPN Fabrics](https://www.cisco.com/c/en/us/td/docs/dcn/dcnm/1151/configuration/lanfabric/cisco-dcnm-lanfabric-configuration-guide-1151/managing-greenfield-vxlan-fabric.html)
* [Auto-Provisioning Border Gateways with Multi-Site Domains](https://www.cisco.com/c/en/us/td/docs/dcn/dcnm/1151/configuration/lanfabric/cisco-dcnm-lanfabric-configuration-guide-1151/border-provisioning-multisite.html )
* [VXLAN EVPN Multi-Site Design and Deployment Whitepaper](https://www.cisco.com/c/en/us/products/collateral/switches/nexus-9000-series-switches/white-paper-c11-739942.html)
* [Cisco Communities - Data Center](https://www.cisco.com/c/en/us/td/docs/dcn/dcnm/1151/configuration/lanfabric/cisco-dcnm-lanfabric-configuration-guide-1151/border-provisioning-multisite.html )

#### Create the DCNM App (Directory Structure) in django
```python
$ python manage.py startapp dcnm
$ ls dcnm/
admin.py  apps.py  __init__.py  migrations  models.py  tests.py  views.py
```

Add the grafana app to cisco-grafana/settings.py:
```python
# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'meraki',
    'dcnm', # Add this
]
```

#### Create Python API Requests functions
```python

DCNM_USER = "admin"
DCNM_PASSWORD = "Cisco123!"
dcnm = '192.168.200.230'

def get_auth_token():
    """
    Building out Auth request. Using requests.post to make a call to the Auth Endpoint
    """
    url = 'https://{}/rest/logon'.format(dcnm)       # Endpoint URL
    data= '{"expirationTime": 360000}'
    resp = requests.post(url, auth=HTTPBasicAuth(DCNM_USER, DCNM_PASSWORD), verify=False, data=data)  # Make the POST Request
    token = resp.json()['Dcnm-Token']    # Retrieve the Token from the returned JSON
    print("Token Retrieved: {}".format(token))  # Print out the Token
    return token    # Create a return statement to send the token back for later use


def dcnm_http_get(dcnm_class):
    token = get_auth_token() # Get a Token
    url = url = 'https://{}/rest{}'.format(dcnm, dcnm_class)  #Network Device endpoint
    payload = {}
    hdr = {'Dcnm-Token': token, 'content-type' : 'application/json'}
    querystring = ''

    resp = requests.get(url, headers=hdr, verify=False, data=payload)  # Make the Get Request
    device_list = resp.json() # Capture data from the controller
    pp.pprint(device_list)
    return device_list # Pretty print the data
```
Run the function and validate the output.  You should receive a '200' response and your organisation id.  If not  (i.e. you receive an http response of 400), check that your API key and URL is correct - you can test the API call in Postman to validate that it's been enabled.

```python
dcnm_http_get('/inventory/switches')
dcnm_http_get('/control/fabrics')

```python
def get_dcnm_network_device(query_class):
            try:
                devices = dcnm_http_get(query_class)
                for device in devices:
                    if device['fabricType'] == 'Switch_Fabric':
                        device_entry=dcnm_network_device(
                            dcnm_addr = dcnm,
                            asn = device['asn'],
                            deviceType = device['deviceType'],
                            fabricId = device['fabricId'],
                            fabricName = device['fabricName'],
                            fabricTechnology = device['fabricTechnology'],
                            fabricType = device['fabricType'],
                            id = device['id'],
                            networkTemplate = device['networkTemplate'],
                            ADVERTISE_PIP_BGP = device['nvPairs']['ADVERTISE_PIP_BGP'],
                            ANYCAST_GW_MAC = device['nvPairs']['ANYCAST_GW_MAC'],
                            ANYCAST_RP_IP_RANGE = device['nvPairs']['ANYCAST_RP_IP_RANGE'],
                            BFD_ENABLE = device['nvPairs']['BFD_ENABLE'],
                            BFD_AUTH_ENABLE = device['nvPairs']['BFD_AUTH_ENABLE'],
                            BGP_AS = device['nvPairs']['BGP_AS'],
                            BGP_AUTH_ENABLE = device['nvPairs']['BGP_AUTH_ENABLE'],
                            DCI_SUBNET_RANGE = device['nvPairs']['DCI_SUBNET_RANGE'],
                            DCI_SUBNET_TARGET_MASK = device['nvPairs']['DCI_SUBNET_TARGET_MASK'],
                            DHCP_ENABLE = device['nvPairs']['DHCP_ENABLE'],
                            ENABLE_EVPN = device['nvPairs']['ENABLE_EVPN'],
                            ENABLE_NXAPI = device['nvPairs']['ENABLE_NXAPI'],
                            FABRIC_INTERFACE_TYPE = device['nvPairs']['FABRIC_INTERFACE_TYPE'],
                            FABRIC_MTU = device['nvPairs']['FABRIC_MTU'],
                            FABRIC_NAME = device['nvPairs']['FABRIC_NAME'],
                            L2_SEGMENT_ID_RANGE = device['nvPairs']['L2_SEGMENT_ID_RANGE'],
                            L3_PARTITION_ID_RANGE = device['nvPairs']['L3_PARTITION_ID_RANGE'],
                            LINK_STATE_ROUTING = device['nvPairs']['LINK_STATE_ROUTING'],
                            LINK_STATE_ROUTING_TAG = device['nvPairs']['LINK_STATE_ROUTING_TAG'],
                            LOOPBACK0_IP_RANGE = device['nvPairs']['LOOPBACK0_IP_RANGE'],
                            LOOPBACK1_IP_RANGE = device['nvPairs']['LOOPBACK1_IP_RANGE'],
                            MULTICAST_GROUP_SUBNET = device['nvPairs']['MULTICAST_GROUP_SUBNET'],
                            NETWORK_VLAN_RANGE = device['nvPairs']['NETWORK_VLAN_RANGE'],
                            OSPF_AREA_ID = device['nvPairs']['OSPF_AREA_ID'],
                            OSPF_AUTH_ENABLE = device['nvPairs']['OSPF_AUTH_ENABLE'],
                            REPLICATION_MODE = device['nvPairs']['REPLICATION_MODE'],
                            RR_COUNT = device['nvPairs']['RR_COUNT'],
                            SERVICE_NETWORK_VLAN_RANGE = device['nvPairs']['SERVICE_NETWORK_VLAN_RANGE'],
                            SUBNET_RANGE = device['nvPairs']['SUBNET_RANGE'],
                            replicationMode = device['replicationMode'],
                            templateName = device['templateName'])
                        device_entry.save()
                aci_model_pruner(dnac_network_device.objects.all(), obj_type="DCNM Fabric", retention_period=30)
            except:
                print('Unable to query devices on DCNM {}'.format(dcnm))


def get_dcnm_network_switch(query_class):
    try:
        devices = dcnm_http_get(query_class)
        for device in devices:
            device_entry=dcnm_network_switch(
                dcnm_addr = dcnm,
                activeSupSlot = device['activeSupSlot'],
                availPorts = device['availPorts'],
                consistencyState = device['consistencyState'],
                cpuUsage = device['cpuUsage'],
                fabricName = device['fabricName'],
                health = device['health'],
                hostName = device['hostName'],
                ipAddress = device['ipAddress'],
                isVpcConfigured = device['isVpcConfigured'],
                licenseViolation = device['licenseViolation'],
                logicalName = device['logicalName'],
                managable = device['managable'],
                memoryUsage = device['memoryUsage'],
                mode = device['mode'],
                model = device['model'],
                network = device['network'],
                numberOfPorts = device['numberOfPorts'],
                present = device['present'],
                release = device['release'],
                serialNumber = device['serialNumber'],
                upTime = device['upTime'],
                vendor = device['vendor'],
                vpcDomain = device['vpcDomain']
                )
            device_entry.save()
        aci_model_pruner(dnac_network_device.objects.all(), obj_type="DCNM Switch", retention_period=30)
    except:
        print('Unable to query devices on DCNM {}'.format(dcnm))
Verify devices have been retrieved and written to database with PgAdmin.
```

### Grafana Visualisations

#### Installation
Installation of Grafana is straightforward - you can find guides for Linux, macOS, Windows and containers
here [Grafana Installation](https://grafana.com/docs/grafana/latest/installation/)

Point Grafana to PostgresSQL as below
![alt text](https://github.com/j-sulliman/j-sulliman.github.io/blob/master/Postgres%20datasource.png?raw=true)

Create a new dashboard and add a new panel - configure **query options** as below.  Note - if you don't configure __"aggregate: count"__ as shown, you'll most likely receive an error.

Select PieChartv2 from the right, optionally change the PieChart type to __donut__, add the labels name, value and percent and give the chart a title.

Your preview pane should now look like below - click save and apply
![alt text](https://github.com/j-sulliman/j-sulliman.github.io/blob/master/meraki_query.png?raw=true)

Return to the dashboard and duplicate the Devices PieChart, edit the duplicate chart, in the **query options**, replace **model** metric columns with **firmware**, you'll now have a summary of firmware breakdowns in the environment also.

* Return to the dashboard and add another panel, again select the **MerakiDevices** table.
* From the right hand pane, select **table**
* In the **query options**, select "format as: table"
* Add columns of interest to the table

![alt text](https://github.com/j-sulliman/j-sulliman.github.io/blob/master/Meraki_device_table.png?raw=true)

If you've managed to follow the above successfully, your dashboard should look like below.
![alt text](https://github.com/j-sulliman/j-sulliman.github.io/blob/master/Meraki%20Dashboard%20Example.png?raw=true)


Using the [Meraki API Documentation](https://developer.cisco.com/meraki/api-v1/) as a guide, you can experiment with this process to create visualisations and graphs for other devices.

...follow up for DCNM dashboard to follow soon.

Jamie
